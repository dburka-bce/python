<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>NumPy </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="NumPy ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="numpy">NumPy</h1>

<p>A <a href="http://www.numpy.org">NumPy</a> (numeric python) egy alap Python csomag, matematikai és tudományos számítások elvégzésére.</p>
<pre><code class="lang-python">import numpy as np
</code></pre>
<h2 id="tömbök">Tömbök</h2>
<p>Numpy tömböket listákból lehet létrehozni, és az elemeikre a listákkal megegyező módon lehet hivatkozni.</p>
<pre><code class="lang-python">import numpy as np

a = np.array([1, 2, 3])
print(type(a))
print(a)
print(a[1])
</code></pre>
<pre><code>&lt;class 'numpy.ndarray'&gt;
[1 2 3]
2
</code></pre>
<p>A listákkal ellentétben azonban a tömbök több dimenziósak is lehetnek. Ebből adódóan a szokásos <code>len</code> paranccsal nem igazán lehetne meghatározni a méretüket. Helyette a <code>shape</code> függvény tartozik az adattípushoz, melynek segítségével az egyes dimenziók méretét kapjuk vissza egy <code>tuple</code>-ben. Az elemek lekérdezése is eltér: bár egymásba ágyazott listák segítségével állítjuk elő a több dimenziós tömböt, annak az elemeire már nem a listáknál megszokott <code>lista[i][j]</code> szintakszissal hivatkozunk, hanem egy pár zárójel között vesszővel elválasztva soroljuk fel az indexeket.</p>
<pre><code class="lang-python">import numpy as np

b = np.array([[1, 2, 3], [4, 5, 6]])
print(b)
print(b.shape)
print(b[1, 2])
</code></pre>
<pre><code>[[1 2 3]
 [4 5 6]]
(2, 3)
6
</code></pre>
<p>Az eltérő indexelés oka, hogy a tömbök esetén létezik olyan megkötés, ami a listáknál nem. Mégpedig az, hogy az egyes dimenziók mentén az elemek méretének meg kell egyeznie. A fenti egyszerű, két dimenziós példában ez azt jelenti, hogy mindkét sorban 3 és minden oszlopban 2 elem kell, hogy legyen. Ellenkező esetben egy hosszú hibajelzést kapunk eredményül. (Az üzenet egyébként csak arra figyelmeztet, hogy ez a megközelítés már elavult, és ilyen esetben másképp kell eljárni.)</p>
<pre><code class="lang-python">import numpy as np

b = np.array([[1, 2, 3], [4, 5]])
</code></pre>
<pre><code>&lt;ipython-input-41-ca69b995a7b8&gt;:3: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
  b = np.array([[1, 2, 3], [4, 5]])
</code></pre>
<p>Gyakran nem akarunk már feltöltött tömböket használni, de jobb nem egy üres tömbbel indítani a számításokat. A tömböt alapértelmezetten feltölthetjük egy adott értékkel (a nullával és eggyel való feltöltésnek külön függvénye is van), kitölthetjük egy n dimenziós egységvektornak megfelelő értékekkel, vagy akár 0 és 1 közé eső véletlen számokkal is. Az új tömb méretét legtöbb esetben egy <code>tuple</code> formájában kell megadni kivéve, ha egy dimenziós a tömb, vagy ha egység vektort/mátrixot akarunk építeni. Utóbbi esetben minden dimenzió méretének meg kell egyezni, ezért elég egy számot megadni.</p>
<pre><code class="lang-python">import numpy as np

print(&quot;Csupa 7&quot;)
print(np.full((3, 3), 3))
print(&quot;Csupa 0&quot;)
print(np.zeros((3, 3)))
print(&quot;Csupa 1&quot;)
print(np.ones((3, 3)))
print(&quot;Egység mátrix&quot;)
print(np.eye(3))
print(&quot;Csupa véletlen&quot;)
print(np.random.random((3, 3)))
</code></pre>
<pre><code>Csupa 7
[[3 3 3]
 [3 3 3]
 [3 3 3]]
Csupa 0
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
Csupa 1
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Egység mátrix
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
Csupa véletlen
[[0.74032554 0.9008071  0.98328793]
 [0.88390137 0.88951462 0.10827427]
 [0.87114709 0.42487741 0.04573846]]
</code></pre>
<h2 id="indexelés-és-szeletelés-slicing">Indexelés és szeletelés (slicing)</h2>
<p>Az előzőekben láthattuk, hogy többdimenziós tömbök esetén vesszővel elválasztott indexeket kell használni. Azonban a listáknál is lehetőség volt egyszerre több értéké lekérni. Amennyiben minden index helyére egyforma méretű egészekből álló szekvenciát írunk, akkor azok alapján a méretüknek megfelelő számú értéket kérdezhetünk le a tömbből. Az első lekérdezett érték a szekvenciák első indexeiből összeállított indexű eleme, a második a szekvenciák második eleméből áll elő, és így tovább.</p>
<pre><code class="lang-python">import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

print(a[[1, 2, 3], [0, 1, 2]])
print(a[1, 0])
print(a[2, 1])
print(a[3, 2])
</code></pre>
<pre><code>[ 4  8 12]
4
8
12
</code></pre>
<p>A lekérdezéshez változók vagy függvények eredményeképp is előállíthatjuk a megfelelő szekvenciákat. Az alábbi példában az első szekvencia a <code>range</code> függvénnyel szinte megegyező funkcionalitású <code>np.arange</code> függvényt alkalmazza, tehát lényegében a [0, 1, 2, 3] indexekből álló lista az első index. A második pedig a <code>b</code> változóban tárolt vektor (egy dimenziós tömb).</p>
<pre><code class="lang-python">import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
b = np.array([0, 2, 0, 1])

print(a[np.arange(4), b])
</code></pre>
<pre><code>[ 1  6  7 11]
</code></pre>
<p>De működnek a listák kapcsán megismert <em>slicing</em> megoldások is.</p>
<pre><code class="lang-python">import numpy as np

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

print(a)
print(a[:2, 1:3])
</code></pre>
<pre><code>[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
[[2 3]
 [6 7]]
</code></pre>
<h1 id="boolean-indexelés">Boolean indexelés</h1>
<p>Lehetséges egy Numpy tömböt egy méretében megegyező True/False értékekkel feltöltött tömbbel indexelni. A végeredmény egy 1 dimenziós tömb, amelynek elemei az indexelő tömbben True értékekkel megjelölt elemek.</p>
<pre><code class="lang-python">import numpy as np

a = np.array([[1, 2], [3, 4], [5, 6]])
bool_idx = (a &gt; 2)

print(bool_idx)
print(a[bool_idx])
</code></pre>
<pre><code>[[False False]
 [ True  True]
 [ True  True]]
[3 4 5 6]
</code></pre>
<h1 id="adattípusok">Adattípusok</h1>
<p>A NumPy tömbjei és a bennük található értékek a modul saját adattípusait használják a Python beépített típusai helyett. Ezek az adattípusok a <code>dtype</code> tulajdonság lekérdezésével tekinthetők meg vagy éppen kényszeríthetők ki a tömb létrehozásakor.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([1, 2])
y = np.array([1.0, 2.0])
z = np.array([1, 2], dtype=np.int64)

print(x.dtype)
print(y.dtype)
print(z.dtype)
</code></pre>
<pre><code>int32
float64
int64
</code></pre>
<p>Az adattípusok végén a szám azt jelöli, hogy a memóriában hány bitet használ fel a rendszer egy érték tárolására. Az <code>int32</code> például 32 biten tárolja az értékeket. Ebből az első bit adja meg az előjelet, a többi pedig a kettes számrendszerben megadott értéket tárolja. $2^{31}=2 147 483 648$, tehát, mivel pozitív irányban a nullát is tárolni kell, az <code>int32</code> lehetséges értékei -2 147 483 648 és 2 147 483 647 között vannak.</p>
<p>Ezek nagyon nagy számok, de a Python korlátlan integer típusához képest elenyészőek. Az ilyen jellegű megkötések jelentősen javíthatják az nagy méretű vektorokkal végzett műveletek futási idejét, ezért ezek a Numpy alapértelmezett beállításai. De szükség esetén ezek a korlátozások feloldhatók.</p>
<h1 id="matematikai-műveletek">Matematikai műveletek</h1>
<p>A tömbök közti alapműveletek a standard jelölésekkel, vagy a megfelelő NumPy függvénnyel végezhetők el.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])

print(&quot;Összeadás&quot;)
print(x + y)
print(np.add(x, y))
print(&quot;\nKivonás&quot;)
print(x - y)
print(np.subtract(x, y))
print(&quot;\nSzorzat&quot;)
print(x * y)
print(np.multiply(x, y))
print(&quot;\nHányados&quot;)
print(x / y)
print(np.divide(x, y))
</code></pre>
<pre><code>Összeadás
[[ 6  8]
 [10 12]]
[[ 6  8]
 [10 12]]

Kivonás
[[-4 -4]
 [-4 -4]]
[[-4 -4]
 [-4 -4]]

Szorzat
[[ 5 12]
 [21 32]]
[[ 5 12]
 [21 32]]

Hányados
[[0.2        0.33333333]
 [0.42857143 0.5       ]]
[[0.2        0.33333333]
 [0.42857143 0.5       ]]
</code></pre>
<p>A hányados meghatározása során vigyázni kell, hogy a nevezőben szereplő vektor elemei között ne legyen nulla. Ellenkező esetben az osztás eredménye végtelen (<code>np.inf</code>) lesz, és megjelenik egy figyelmeztetés az outputon.</p>
<p>Meghatározható még a négyzetgyök vagy akár két tömb skalárszorzata is.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6], [7, 8]])

print(&quot;Gyökvonás&quot;)
print(np.sqrt(x))
print(&quot;\nSkalárszorzat&quot;)
print(x.dot(y))
print(np.dot(x, y))
</code></pre>
<pre><code>Gyökvonás
[[1.         1.41421356]
 [1.73205081 2.        ]]

Skalárszorzat
[[19 22]
 [43 50]]
[[19 22]
 [43 50]]
</code></pre>
<p>Számos matematikai művelet és optimalizálási folyamat során is gyakran van szükség a tömbök transzponálására.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print(&quot;Eredeti&quot;)
print(x)
print(&quot;\nTranszponált&quot;)
print(x.T)
</code></pre>
<pre><code>Eredeti
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Transzponált
[[1 4 7]
 [2 5 8]
 [3 6 9]]
</code></pre>
<p>A tömbök többdimenziós jellege miatt az értékeik összeadása sem olyan triviális, mint egy lista elején. Összeadható az összes elem, de lehetőség van egy adott dimenzió mentén aggregálni az értékeket. Utóbbi esetben az eredmény egy az eredetinél eggyel kevesebb dimenzióval rendelkező tömb.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2], [3, 4]])

print(np.sum(x))
print(np.sum(x, axis=0))
print(np.sum(x, axis=1))
</code></pre>
<pre><code>10
[4 6]
[3 7]
</code></pre>
<h1 id="broadcasting">Broadcasting</h1>
<p>Lehetőség van arra, hogy egy tömb megadott indexű elemeit egy másik tömb elemeivel felülírjuk vagy módosítsuk, akár abban az esetben is, ha a műveletben szereplő tömbök nem azonos méretűek.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])

y = np.empty_like(x)

for i in range(4):
    y[i, :] = x[i, :] + v
    
print(y)
</code></pre>
<p>Ebben az esetben az egyenlőség jobb oldalán álló 2 tömb ugyanolyan dimenziójú.</p>
<pre><code>[[ 2  2  4]
 [ 5  5  7]
 [ 8  8 10]
 [11 11 13]]
</code></pre>
<p>A <code>np.empty_like(x)</code> létrehoz egy tömböt, ami pontosan olyan méretű, mint a paraméterként átadott tömb (ugyanez érhető el azzal, ha lekérdezzük a tömb <code>shape</code> tulajdonságát, és azt felhasználva generálunk egy új tömböt fix értékkel).</p>
<p>A fenti példában végigmegyünk az -- ekkor még üres -- <code>y</code> tömb sorain, és az <code>x</code> soraival töltjük fel, de úgy, hogy minden sorhoz hozzáadódik a <code>v</code> tömb értéke. Természetesen ez csak akkor működhet, ha minden műveletnél megfelelnek egymásnak a tömbök dimenziói.</p>
<pre><code class="lang-python">x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])  
x + np.array([1, 0, 1])  
</code></pre>
<p>Ebben az esetben össze tudja adni, annak ellenére, hogy a két tömb dimenziója nem egyezik meg. Az x tömb 4x3-as, addig a másik 1x3-as.</p>
<p>Ez a művelet ekvivalens ezzel:</p>
<pre><code class="lang-python">x + np.array([[1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1]])  
</code></pre>
<p>Viszont ez hibát fog dobni:</p>
<pre><code class="lang-python">x + np.array([1, 0])
</code></pre>
<p>Abban az esetben, ha műveletekhez szükség lenne a dimenziók megváltoztatására: a <code>tile</code> és a <code>reshape</code> függvények lehetnek segítségünkre. Előbbi egy tömböt a megadott dimenziók mentén többször megismétel, így építve új tömböt. Utóbbi pedig egy tömböt átalakít a megadott dimenzióra úgy, hogy az értékeket megtartja, és eligazgatja az új helyekre. Természetesen a két tömb teljes elemszáma meg kell egyezzen.</p>
<pre><code class="lang-python">import numpy as np

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])
    
print(&quot;Tile&quot;)
print(v)
print(np.tile(v, (4, 1)))
print(&quot;\nReshape&quot;)
print(x)
print(np.reshape(x+v, (2, 6)))
</code></pre>
<pre><code>Tile
[1 0 1]
[[1 0 1]
 [1 0 1]
 [1 0 1]
 [1 0 1]]

Reshape
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
[[ 2  2  4  5  5  7]
 [ 8  8 10 11 11 13]]
</code></pre>
<h1 id="feladatok">Feladatok</h1>
<ol>
<li>Írj egy függvényt, amely első paraméterként átadott 2D tömbből kinyeri azokat az értékeket, amelyek a második 2D tömbben is megtalálhatóak!</li>
<li>Írj egy függvényt, amely visszaadja a paraméterként átadott lista maximumának indexét!</li>
<li>Írj egy függvényt, amely kiszámítja a paraméterként átadott n dimenziós Numpy tömbben található számok átlagát!</li>
<li>Írj egy függvényt, amely kiszámítja a paraméterként átadott percentilisét a szintén paraméterként átadott tömb értékeiből! (<a href="https://hu.wikiqube.net/wiki/Percentile">https://hu.wikiqube.net/wiki/Percentile)!</a>!)</li>
</ol>
<h1 id="ajánlott-irodalom">Ajánlott irodalom</h1>
<p>Mátrixaritmetika iránt érdeklődők számára. Nem képezi a tananyag részét, de a leckében alkalmazott példák megértéséhez hozzásegíthet.</p>
<p><a href="https://mek.oszk.hu/00800/00860/00860.pdf">Puskás Csaba, Szabó Imre, Tallos Péter: LINEARIS ALGEBRA</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dburka-bce/python/blob/main/python_advanced/numpy/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
